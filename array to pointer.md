###二维数组和二级指针

我在矩阵乘法中使用二级指针，没想到这个事情没有想象的那么easy,还是踩了点坑的，于是在网上找了篇[blog](http://www.cppblog.com/glxhyt/archive/2011/11/21/160668.html),下面稍微整理

Fun (int \*\*p){}这里面的int \*\*p 这里的p不是二维数组的指针，而是`指向指针的指针`，即二级指针。

正确的二维数组的指针应该是：Int a[2][2];Int (*p)[2]; 定义时`无论数组维数，只可忽略第一维`

例如：int a[2][2]={0，1，2，3};

int \*\*p=(int \*\*)a;//强制将二维数组指针转为指向指针的指针

则此时p[0]=0;p[1]=1;p[2]=2;p[3]=3;

而p[0][0]=\*(\*(p+0)+0)=**p；

p[0][1]=\*(\*(p+0)+1)；

对于p[0][0]：由于\*p=0; ====> \*\*p=\*(0);引用地址为零的内存，必然是错误的。

对于p[0][1]=\*(\*p+1)====>\*(4),引用了非法内存同样，

对于p[1][0]=\*(1)，p[1][1]=\*(5),均引用了非法内存所以说，二位数组并不能简单的转换成指向指针的指针。 

```cpp
#include <iostream>
void fun(char ** p){
    char (*p1)[10] = (char(*)[10])p;
    std::cout<<p1[0][0]<<std::endl;
}

int main(int argc, char* argv[]){
    char data[][10] = {"abc","def"};
    fun((char **)data);
    return 0;
}
```

###坑

在vs中，有一个大坑

```c
void fun(char ** p, int m, const int n){
    char (*p1)[n] = (char(*)[n])p;
    std::cout<<p1[0][0]<<std::endl;
}
```

在g++中以上代码没有任何问题，在vs中就有问题了，提示只能使用常数,不能使用const值来定义数组维度

所以最后只能封装Matrix类进行操作。